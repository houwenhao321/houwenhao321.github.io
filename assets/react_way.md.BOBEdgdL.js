import{_ as a,c as t,o,a2 as r}from"./chunks/framework.DRvQ3jNO.js";const p=JSON.parse('{"title":"way","description":"","frontmatter":{"layout":"doc","title":"way"},"headers":[],"relativePath":"react/way.md","filePath":"react/way.md"}'),c={name:"react/way.md"};function i(l,e,s,d,u,h){return o(),t("div",null,[...e[0]||(e[0]=[r('<h1 id="我们要知道一下自己为什么要用react" tabindex="-1">我们要知道一下自己为什么要用React <a class="header-anchor" href="#我们要知道一下自己为什么要用react" aria-label="Permalink to &quot;我们要知道一下自己为什么要用React&quot;">​</a></h1><p>本篇就是探讨一下我自己为什么使用React。你们也可以想一下，自己为什么要选择使用React。</p><h2 id="与-vue2-的对比" tabindex="-1">与 Vue2 的对比 <a class="header-anchor" href="#与-vue2-的对比" aria-label="Permalink to &quot;与 Vue2 的对比&quot;">​</a></h2><h3 id="_1-组件化思路-函数式-vs-选项式" tabindex="-1">1. 组件化思路：函数式 vs 选项式 <a class="header-anchor" href="#_1-组件化思路-函数式-vs-选项式" aria-label="Permalink to &quot;1. 组件化思路：函数式 vs 选项式&quot;">​</a></h3><p>React 从一开始就拥抱“一切都是函数”的思想，组件即函数，返回即 UI。<br> Vue2 的“选项式”写法（data、methods、computed 分门别类）对新手直观，但业务复杂后，同一个逻辑被迫拆到不同选项里，阅读时需要在文件里上下“跳格子”。<br> React 用函数组合解决问题，配合 hooks，可以把“状态 + 副作用 + 工具函数”收拢到一个自定义 hook 里，逻辑复用天然就是“拆函数”，更符合 JavaScript 的直觉。</p><h3 id="_2-数据更新-显式-setstate-vs-魔法双向绑定" tabindex="-1">2. 数据更新：显式 setState vs 魔法双向绑定 <a class="header-anchor" href="#_2-数据更新-显式-setstate-vs-魔法双向绑定" aria-label="Permalink to &quot;2. 数据更新：显式 setState vs 魔法双向绑定&quot;">​</a></h3><p>Vue2 的 v-model 让表单场景极其丝滑，但“魔法”也会带来隐式更新：</p><ul><li>对象新增属性要用 Vue.set；</li><li>数组索引修改要被重写方法拦截；</li><li>调试时常常出现“我明明改了值，视图怎么不动”的问号脸。</li></ul><p>React 的 setState/useState 看起来啰嗦，却把所有变化摊平成“一次快照”，调试器里能清晰看到每一次调用栈。<br> 配合不可变数据，时间旅行调试（Redux DevTools）可以直接回放整个用户会话，排查问题像放电影。</p><h3 id="_3-生态与-全家桶-自由度" tabindex="-1">3. 生态与“全家桶”自由度 <a class="header-anchor" href="#_3-生态与-全家桶-自由度" aria-label="Permalink to &quot;3. 生态与“全家桶”自由度&quot;">​</a></h3><p>Vue2 官方提供 Vuex + Vue-Router + axios 的“官方四件套”，起步省心，但想换思路时会被约定束缚。<br> React 只专注“视图层”，状态方案可以今天 Redux、明天 Zustand、后天 Jotai；路由可以 React Router，也可以 Reach Router；请求可以 axios、swr、react-query 自由拼装。<br> 对喜欢“搭乐高”的团队，React 的松散生态反而成了长期优势：技术栈可以随业务成长渐进升级，而不是被“全家桶”一次性锁死版本。</p><h3 id="_4-性能优化-手动-钥匙-vs-自动-响应式" tabindex="-1">4. 性能优化：手动“钥匙” vs 自动“响应式” <a class="header-anchor" href="#_4-性能优化-手动-钥匙-vs-自动-响应式" aria-label="Permalink to &quot;4. 性能优化：手动“钥匙” vs 自动“响应式”&quot;">​</a></h3><p>Vue2 的响应式系统会自动收集依赖，大部分场景“不用想性能”。<br> 但遇到“大列表 + 深层嵌套”时，watcher 数量爆炸，一样要手动写 <code>Object.freeze</code> 或 <code>v-once</code> 做降级。<br> React 默认“ father knows best ”——父级更新子级默认全刷；<br> 想跳过？给子节点一把“钥匙”（key）或包一层 <code>React.memo</code> 就行。<br> 策略不同，但 React 的“显式优化”在超大型列表（千行表格、虚拟滚动）里反而更容易做精细控制，配合 <code>useMemo</code>/<code>useCallback</code> 可以把“重计算”切成可控粒度。</p><h3 id="_5-typescript-体验-渐进式-vs-装饰器" tabindex="-1">5. TypeScript 体验：渐进式 vs 装饰器 <a class="header-anchor" href="#_5-typescript-体验-渐进式-vs-装饰器" aria-label="Permalink to &quot;5. TypeScript 体验：渐进式 vs 装饰器&quot;">​</a></h3><p>Vue2 的 TS 支持靠 <code>vue-class-component</code> + <code>vue-property-decorator</code>，写起来像 Java，装饰器语法一度成为“黑魔法”。<br> React 从 0.14 起就提供 <code>.d.ts</code>，泛型组件 <code>React.FC&lt;Props&gt;</code> 随写随有，配合 <code>useState&lt;number&gt;</code> 一行搞定类型推断。<br> 对习惯原生 TS 的团队，React 的学习曲线几乎为零；而 Vue2 的 TS 迁移常常要“先学一套装饰器规则”，再学一套 Vue 规则，双重成本。</p><h3 id="_6-小结-我为何仍选-react" tabindex="-1">6. 小结：我为何仍选 React <a class="header-anchor" href="#_6-小结-我为何仍选-react" aria-label="Permalink to &quot;6. 小结：我为何仍选 React&quot;">​</a></h3><p>Vue2 的“开箱即用”让人十分钟就能搭一个后台管理系统；<br> 但当项目寿命拉到三年以上、页面复杂度逼近桌面软件时，我更需要：</p><ul><li>可预测的数据流——调试不猜魔法；</li><li>自由拼装的技术栈——升级不拆全家桶；</li><li>函数式的组合能力——复用不靠 mixin；</li><li>庞大社区踩过的坑——搜 StackOverflow 就能救命。</li></ul><p>这些理由，让我把技术债降到最低，也让我们在凌晨两点上线时，心里不那么慌。</p><h3 id="_1-组件化开发" tabindex="-1">1. 组件化开发 <a class="header-anchor" href="#_1-组件化开发" aria-label="Permalink to &quot;1. 组件化开发&quot;">​</a></h3><p>React的组件化开发模式让我能够将页面拆分成多个独立的组件，每个组件都有自己的状态和逻辑。这使得代码更易于维护和复用。而Vue2也有组件化开发的模式，但是我个人更倾向于React的组件化开发模式。</p><h3 id="_2-虚拟dom" tabindex="-1">2. 虚拟DOM <a class="header-anchor" href="#_2-虚拟dom" aria-label="Permalink to &quot;2. 虚拟DOM&quot;">​</a></h3><p>React使用虚拟DOM来提高渲染效率。当组件的状态发生变化时，React会对比虚拟DOM的差异，只更新需要改变的部分，而不是重新渲染整个组件。而Vue2也有虚拟DOM的机制，但是我个人更倾向于React的虚拟DOM机制。</p><h3 id="_3-单向数据流" tabindex="-1">3. 单向数据流 <a class="header-anchor" href="#_3-单向数据流" aria-label="Permalink to &quot;3. 单向数据流&quot;">​</a></h3><p>React采用单向数据流的模式，即数据只能从父组件流向子组件。这使得组件之间的通信更加清晰和可预测。而Vue2也有单向数据流的模式，但是我个人更倾向于React的单向数据流模式。</p><h2 id="与-vue3-对比" tabindex="-1">与 Vue3 对比 <a class="header-anchor" href="#与-vue3-对比" aria-label="Permalink to &quot;与 Vue3 对比&quot;">​</a></h2><h3 id="_1-响应式原理" tabindex="-1">1. 响应式原理 <a class="header-anchor" href="#_1-响应式原理" aria-label="Permalink to &quot;1. 响应式原理&quot;">​</a></h3><p>Vue3 使用 Proxy 实现响应式，能深度监听对象与数组，无需像 Vue2 那样手动 <code>$set</code>。React 则依赖 <code>setState</code> 或 hooks 中的 <code>useState</code>，通过显式更新触发重新渲染。相比之下，Vue3 的响应式更“自动化”，而 React 的不可变数据流让变化轨迹更清晰，调试时更容易追溯。</p><h3 id="_2-composition-api-vs-hooks" tabindex="-1">2. Composition API vs Hooks <a class="header-anchor" href="#_2-composition-api-vs-hooks" aria-label="Permalink to &quot;2. Composition API vs Hooks&quot;">​</a></h3><p>Vue3 的 Composition API 通过 <code>setup()</code> 组织逻辑，提供 <code>ref</code>、<code>reactive</code>、<code>watchEffect</code> 等工具；React 的 Hooks 则使用 <code>useState</code>、<code>useEffect</code>、<code>useMemo</code> 等。两者都能实现逻辑复用，但 React Hooks 必须“按顺序”调用，Vue3 的 Composition API 没有顺序限制，也更接近传统 JS 写法，对新手更友好。</p><h3 id="_3-性能优化" tabindex="-1">3. 性能优化 <a class="header-anchor" href="#_3-性能优化" aria-label="Permalink to &quot;3. 性能优化&quot;">​</a></h3><p>Vue3 在编译期做静态提升（hoistStatic）、缓存事件句柄（cacheHandlers），并引入基于 Proxy 的细粒度依赖收集，减少不必要的组件更新。React 18 则通过自动批处理、并发渲染（Concurrent Rendering）与 <code>useTransition</code> / <code>useDeferredValue</code> 把“可中断”渲染带到生产环境。两者思路不同：Vue3 偏向“编译时优化”，React 偏向“运行时调度”。</p><h3 id="_4-生态与工程化" tabindex="-1">4. 生态与工程化 <a class="header-anchor" href="#_4-生态与工程化" aria-label="Permalink to &quot;4. 生态与工程化&quot;">​</a></h3><ul><li><strong>路由</strong>：Vue Router 4 与 React Router 6 都支持嵌套路由、懒加载，但 Vue Router 的“基于文件”约定式配置更简洁。</li><li><strong>状态</strong>：Vue3 官方推荐 Pinia，API 简洁、去除了 Vuex 的 mutation；React 则仍是 Redux / Zustand / Jotai / Recoil 百家争鸣，选择丰富但学习曲线陡峭。</li><li><strong>SSR / SSG</strong>：Nuxt3 全栈内置 Nitro，零配置可输出静态或 Serverless 产物；Next.js 则提供 App Router、ISR、React Server Components 等高级能力，社区插件更多，但配置复杂度也更高。</li></ul><h3 id="_5-类型支持" tabindex="-1">5. 类型支持 <a class="header-anchor" href="#_5-类型支持" aria-label="Permalink to &quot;5. 类型支持&quot;">​</a></h3><p>Vue3 源码用 TS 重写，配合 <code>&lt;script setup lang=&quot;ts&quot;&gt;</code> 几乎零成本获得完整类型推断；React 的 <code>FC&lt;Props&gt;</code>、泛型 <code>useState&lt;T&gt;</code> 也支持良好，但需手动维护 <code>.d.ts</code> 或借助第三方库（如 <code>@types/react</code>），项目初期要多写一些样板代码。</p><h3 id="_6-学习曲线与团队经验" tabindex="-1">6. 学习曲线与团队经验 <a class="header-anchor" href="#_6-学习曲线与团队经验" aria-label="Permalink to &quot;6. 学习曲线与团队经验&quot;">​</a></h3><p>如果团队成员已熟悉 Vue2，迁移到 Vue3 几乎无缝；而从零起步，React 的函数式思想与庞大生态可能更具“未来-proof”。但 React 对“规则”更严格（Hooks 顺序、key 的使用、memo 优化），需要团队有更强的 JS 功底；Vue3 则把很多最佳实践内置进框架，让业务代码更“傻瓜式”。</p><h3 id="_7-个人取舍" tabindex="-1">7. 个人取舍 <a class="header-anchor" href="#_7-个人取舍" aria-label="Permalink to &quot;7. 个人取舍&quot;">​</a></h3><p>我依旧选择 React，原因有三：</p><ol><li>并发特性带来的用户体验红利（可中断渲染、Server Components）让我能构建更复杂的富交互应用；</li><li>庞大的社区与工业级方案（Next.js、Relay、React Native）让我“一套技术栈”覆盖 Web、桌面、移动端；</li><li>强制不可变数据与单向数据流，让大型项目的变化可预测，配合 TypeScript 后，重构底气更足。</li></ol><p>当然，Vue3 的优雅 API 与极致性能同样令人心动；技术没有银弹，选型核心还是“团队基因 + 业务场景”。如果你追求“开箱即用”的轻量敏捷，Vue3 是更顺滑的选择；若你想深入底层、打造跨平台长期维护的复杂系统，React 依旧是我的第一答案。</p><h2 id="自己的看法" tabindex="-1">自己的看法： <a class="header-anchor" href="#自己的看法" aria-label="Permalink to &quot;自己的看法：&quot;">​</a></h2><p>其实上边的内容是由Ai生成的，我只是简单的整理了一下。我简单说一下</p><ol><li>一开始逐步进阶学习得时候，都是按照 vue2-&gt;vue3-&gt;react 这个顺序来学习的，所以主观上我更倾向于react。感觉react要相对来说牛一点。</li><li>现实一点，招聘市场上传react前端要比vue前端要贵一点，我觉得贵有贵得道理。</li><li>相对来说react得生态确实要比vue3要大一点。但是vue3的生态也在不断的完善。还是希望vue3的生态能够越来越好。</li></ol><h2 id="最后建议" tabindex="-1">最后建议 <a class="header-anchor" href="#最后建议" aria-label="Permalink to &quot;最后建议&quot;">​</a></h2><ol><li>如果你是新手，我建议你先学习vue2，等你对vue2有了一定的理解后，再学习vue3。</li><li>如果你是有经验的vue2开发者，我建议你先学习react，等你对react有了一定的理解后，再学习vue3。</li><li>如果你是有经验的react开发者，你应该不用别人的建议了。</li><li>如果日常工作中基本上都是使用vue来进行开发，我建议你在一些公司没有明确规定框架得得相对简单得项目里边，可以自己练习使用一下，去感受一下react的优势。</li></ol>',47)])])}const b=a(c,[["render",i]]);export{p as __pageData,b as default};
